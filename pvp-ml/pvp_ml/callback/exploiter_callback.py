import threading
from typing import Any

from pvp_ml.callback.callback import Callback
from pvp_ml.ppo.buffer import Buffer
from pvp_ml.util.adversary_trainer import AdversaryTrainer


class ExploiterCallback(Callback):
    def __init__(
        self,
        experiment_name: str,
        train_main_exploiter: bool,
        main_exploiter_preset: str,
        main_exploiter_delay: int,
        train_league_exploiter: bool,
        league_exploiter_preset: str,
        league_exploiter_delay: int,
        distribute: bool = False,
        num_distributed_rollouts: int = 1,
        num_main_exploiters: int = 1,
        num_league_exploiters: int = 1,
    ):
        super().__init__()
        self._experiment_name = experiment_name
        self._train_main_exploiter = train_main_exploiter
        self._main_exploiter_preset = main_exploiter_preset
        self._main_exploiter_delay = main_exploiter_delay
        self._train_league_exploiter = train_league_exploiter
        self._league_exploiter_preset = league_exploiter_preset
        self._league_exploiter_delay = league_exploiter_delay
        self._num_main_exploiters = num_main_exploiters
        self._num_league_exploiters = num_league_exploiters
        self._distribute = distribute
        self._num_distributed_rollouts = num_distributed_rollouts
        self._threads: list[threading.Thread] = []

    def on_training_start(self) -> None:
        self._check()

    def on_training_end(self) -> None:
        self._check()

    def on_rollout_start(self) -> None:
        assert self._ppo is not None
        if (
            self._train_main_exploiter
            and self._ppo.meta.trained_rollouts >= self._main_exploiter_delay
        ):
            for i in range(self._num_main_exploiters):
                self._threads.append(
                    AdversaryTrainer().run_main_exploiter_trainer(
                        self._experiment_name,
                        self._main_exploiter_preset,
                        i,
                        self._distribute,
                        self._num_distributed_rollouts,
                    )
                )
            self._train_main_exploiter = False

        if (
            self._train_league_exploiter
            and self._ppo.meta.trained_rollouts >= self._league_exploiter_delay
        ):
            for i in range(self._num_league_exploiters):
                self._threads.append(
                    AdversaryTrainer().run_league_exploiter_trainer(
                        self._experiment_name,
                        self._league_exploiter_preset,
                        i,
                        self._distribute,
                        self._num_distributed_rollouts,
                    )
                )
            self._train_league_exploiter = False

        self._check()

    def on_step(self, *args: Any, **kwargs: Any) -> None:
        self._check()

    def on_rollout_end(self, buffer: Buffer) -> None:
        self._check()

    def on_learn_end(self) -> None:
        self._check()

    def _check(self) -> None:
        if any(not t.is_alive() for t in self._threads):
            raise ValueError(f"Background thread has terminated early: {self._threads}")
